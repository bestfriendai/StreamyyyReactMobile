/**
 * Image Optimization and Caching System for React Native Multi-Stream App
 * Provides efficient image loading, caching, and optimization strategies
 */

import React from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Image, Dimensions } from 'react-native';
import { logError, logDebug } from './errorHandler';

interface CacheEntry {
  uri: string;
  timestamp: number;
  size: number;
  dimensions?: { width: number; height: number };
  format?: string;
  quality?: number;
}

interface ImageOptimizationOptions {
  quality?: number; // 0-100
  format?: 'jpeg' | 'png' | 'webp';
  maxWidth?: number;
  maxHeight?: number;
  priority?: 'low' | 'normal' | 'high';
  cache?: boolean;
  placeholder?: string;
  fallback?: string;
}

interface ThumbnailConfig {
  width: number;
  height: number;
  quality: number;
}

class ImageCache {
  private cache: Map<string, CacheEntry> = new Map();
  private loadingPromises: Map<string, Promise<string>> = new Map();
  private maxCacheSize: number = 50 * 1024 * 1024; // 50MB
  private currentCacheSize: number = 0;
  private maxAge: number = 7 * 24 * 60 * 60 * 1000; // 7 days
  
  constructor() {
    this.loadCacheFromStorage();
  }

  /**
   * Load cache data from AsyncStorage
   */
  private async loadCacheFromStorage(): Promise<void> {
    try {
      const cacheData = await AsyncStorage.getItem('image_cache_metadata');
      if (cacheData) {
        const parsed = JSON.parse(cacheData);
        this.cache = new Map(parsed.entries);
        this.currentCacheSize = parsed.totalSize || 0;
        
        // Clean expired entries
        await this.cleanExpiredEntries();
      }
    } catch (error) {
      logError(error as Error, { component: 'ImageCache', action: 'loadCacheFromStorage' });
    }
  }

  /**
   * Save cache metadata to AsyncStorage
   */
  private async saveCacheToStorage(): Promise<void> {
    try {
      const cacheData = {\n        entries: Array.from(this.cache.entries()),\n        totalSize: this.currentCacheSize,\n        lastUpdated: Date.now(),\n      };\n      \n      await AsyncStorage.setItem('image_cache_metadata', JSON.stringify(cacheData));\n    } catch (error) {\n      logError(error as Error, { component: 'ImageCache', action: 'saveCacheToStorage' });\n    }\n  }\n\n  /**\n   * Clean expired cache entries\n   */\n  private async cleanExpiredEntries(): Promise<void> {\n    const now = Date.now();\n    const expiredKeys: string[] = [];\n    \n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp > this.maxAge) {\n        expiredKeys.push(key);\n        this.currentCacheSize -= entry.size;\n      }\n    }\n    \n    // Remove expired entries\n    for (const key of expiredKeys) {\n      this.cache.delete(key);\n      try {\n        await AsyncStorage.removeItem(`image_cache_${this.hashUrl(key)}`);\n      } catch (error) {\n        logError(error as Error, { component: 'ImageCache', action: 'cleanExpiredEntries' });\n      }\n    }\n    \n    if (expiredKeys.length > 0) {\n      logDebug(`Cleaned ${expiredKeys.length} expired cache entries`);\n      await this.saveCacheToStorage();\n    }\n  }\n\n  /**\n   * Ensure cache size doesn't exceed limit\n   */\n  private async enforceSize(): Promise<void> {\n    if (this.currentCacheSize <= this.maxCacheSize) return;\n    \n    // Sort by timestamp (oldest first)\n    const entries = Array.from(this.cache.entries())\n      .sort(([, a], [, b]) => a.timestamp - b.timestamp);\n    \n    // Remove oldest entries until we're under the limit\n    while (this.currentCacheSize > this.maxCacheSize * 0.8 && entries.length > 0) {\n      const [key, entry] = entries.shift()!;\n      this.cache.delete(key);\n      this.currentCacheSize -= entry.size;\n      \n      try {\n        await AsyncStorage.removeItem(`image_cache_${this.hashUrl(key)}`);\n      } catch (error) {\n        logError(error as Error, { component: 'ImageCache', action: 'enforceSize' });\n      }\n    }\n    \n    await this.saveCacheToStorage();\n    logDebug(`Cache size enforced: ${(this.currentCacheSize / 1024 / 1024).toFixed(2)}MB`);\n  }\n\n  /**\n   * Hash URL for storage key\n   */\n  private hashUrl(url: string): string {\n    let hash = 0;\n    for (let i = 0; i < url.length; i++) {\n      const char = url.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * Get cached image\n   */\n  async get(url: string): Promise<string | null> {\n    const entry = this.cache.get(url);\n    if (!entry) return null;\n    \n    // Check if expired\n    if (Date.now() - entry.timestamp > this.maxAge) {\n      this.cache.delete(url);\n      return null;\n    }\n    \n    try {\n      const cachedData = await AsyncStorage.getItem(`image_cache_${this.hashUrl(url)}`);\n      if (cachedData) {\n        // Update timestamp for LRU\n        entry.timestamp = Date.now();\n        return cachedData;\n      }\n    } catch (error) {\n      logError(error as Error, { component: 'ImageCache', action: 'get' });\n    }\n    \n    // Remove invalid entry\n    this.cache.delete(url);\n    return null;\n  }\n\n  /**\n   * Cache image data\n   */\n  async set(url: string, data: string, size: number): Promise<void> {\n    try {\n      const entry: CacheEntry = {\n        uri: url,\n        timestamp: Date.now(),\n        size,\n      };\n      \n      // Store the data\n      await AsyncStorage.setItem(`image_cache_${this.hashUrl(url)}`, data);\n      \n      // Update cache metadata\n      const existingEntry = this.cache.get(url);\n      if (existingEntry) {\n        this.currentCacheSize -= existingEntry.size;\n      }\n      \n      this.cache.set(url, entry);\n      this.currentCacheSize += size;\n      \n      // Enforce cache size limits\n      await this.enforceSize();\n      await this.saveCacheToStorage();\n      \n    } catch (error) {\n      logError(error as Error, { component: 'ImageCache', action: 'set' });\n    }\n  }\n\n  /**\n   * Check if image is cached\n   */\n  has(url: string): boolean {\n    const entry = this.cache.get(url);\n    return entry !== undefined && (Date.now() - entry.timestamp) <= this.maxAge;\n  }\n\n  /**\n   * Clear all cache\n   */\n  async clear(): Promise<void> {\n    try {\n      // Remove all cached images\n      for (const url of this.cache.keys()) {\n        await AsyncStorage.removeItem(`image_cache_${this.hashUrl(url)}`);\n      }\n      \n      // Clear metadata\n      await AsyncStorage.removeItem('image_cache_metadata');\n      \n      // Reset cache\n      this.cache.clear();\n      this.currentCacheSize = 0;\n      \n      logDebug('Image cache cleared');\n    } catch (error) {\n      logError(error as Error, { component: 'ImageCache', action: 'clear' });\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): {\n    totalEntries: number;\n    totalSize: number;\n    sizeInMB: number;\n    maxSize: number;\n    maxSizeInMB: number;\n    usage: number;\n  } {\n    return {\n      totalEntries: this.cache.size,\n      totalSize: this.currentCacheSize,\n      sizeInMB: this.currentCacheSize / 1024 / 1024,\n      maxSize: this.maxCacheSize,\n      maxSizeInMB: this.maxCacheSize / 1024 / 1024,\n      usage: (this.currentCacheSize / this.maxCacheSize) * 100,\n    };\n  }\n}\n\n// Global cache instance\nconst imageCache = new ImageCache();\n\n/**\n * Image optimization utilities\n */\nexport class ImageOptimizer {\n  /**\n   * Optimize Twitch thumbnail URL\n   */\n  static optimizeTwitchThumbnail(\n    templateUrl: string,\n    config: ThumbnailConfig = { width: 320, height: 180, quality: 80 }\n  ): string {\n    if (!templateUrl || !templateUrl.includes('{width}')) {\n      return templateUrl;\n    }\n    \n    // Replace template variables\n    return templateUrl\n      .replace('{width}', config.width.toString())\n      .replace('{height}', config.height.toString());\n  }\n\n  /**\n   * Get responsive image size based on screen dimensions\n   */\n  static getResponsiveSize(\n    containerWidth: number,\n    containerHeight: number,\n    aspectRatio: number = 16 / 9\n  ): { width: number; height: number } {\n    const { width: screenWidth } = Dimensions.get('window');\n    \n    // Use device pixel ratio for high-DPI displays\n    const pixelRatio = 1; // Keep at 1 for performance, can be increased for quality\n    \n    let width = Math.min(containerWidth * pixelRatio, screenWidth * pixelRatio);\n    let height = width / aspectRatio;\n    \n    // Ensure we don't exceed container height\n    if (height > containerHeight * pixelRatio) {\n      height = containerHeight * pixelRatio;\n      width = height * aspectRatio;\n    }\n    \n    // Round to even numbers for better compression\n    return {\n      width: Math.round(width / 2) * 2,\n      height: Math.round(height / 2) * 2,\n    };\n  }\n\n  /**\n   * Generate srcSet for responsive images\n   */\n  static generateSrcSet(\n    baseUrl: string,\n    sizes: { width: number; height: number; suffix: string }[]\n  ): string {\n    return sizes\n      .map(({ width, height, suffix }) => {\n        const url = baseUrl\n          .replace('{width}', width.toString())\n          .replace('{height}', height.toString());\n        return `${url} ${suffix}`;\n      })\n      .join(', ');\n  }\n\n  /**\n   * Preload critical images\n   */\n  static async preloadImages(urls: string[]): Promise<void> {\n    const promises = urls.map(url => {\n      return new Promise<void>((resolve, reject) => {\n        Image.prefetch(url)\n          .then(() => {\n            logDebug(`Preloaded image: ${url}`);\n            resolve();\n          })\n          .catch(error => {\n            logError(error, { component: 'ImageOptimizer', action: 'preloadImages', additionalData: { url } });\n            resolve(); // Don't fail the entire batch\n          });\n      });\n    });\n    \n    await Promise.all(promises);\n  }\n\n  /**\n   * Optimize image URL based on options\n   */\n  static optimizeUrl(\n    url: string,\n    options: ImageOptimizationOptions = {}\n  ): string {\n    if (!url) return url;\n    \n    const {\n      quality = 80,\n      format = 'jpeg',\n      maxWidth,\n      maxHeight,\n    } = options;\n    \n    // For Twitch thumbnails\n    if (url.includes('twitch.tv') && url.includes('{width}')) {\n      const { width, height } = this.getResponsiveSize(\n        maxWidth || 320,\n        maxHeight || 180\n      );\n      \n      return this.optimizeTwitchThumbnail(url, {\n        width,\n        height,\n        quality,\n      });\n    }\n    \n    // For other URLs, return as-is (could be extended for other CDNs)\n    return url;\n  }\n}\n\n/**\n * Custom hook for optimized image loading\n */\nexport const useOptimizedImage = (\n  url: string,\n  options: ImageOptimizationOptions = {}\n) => {\n  const [imageUri, setImageUri] = React.useState<string | null>(null);\n  const [loading, setLoading] = React.useState(true);\n  const [error, setError] = React.useState<string | null>(null);\n  \n  const optimizedUrl = React.useMemo(() => {\n    return ImageOptimizer.optimizeUrl(url, options);\n  }, [url, options]);\n  \n  React.useEffect(() => {\n    if (!optimizedUrl) {\n      setLoading(false);\n      return;\n    }\n    \n    const loadImage = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n        \n        // Check cache first\n        if (options.cache !== false) {\n          const cachedUri = await imageCache.get(optimizedUrl);\n          if (cachedUri) {\n            setImageUri(cachedUri);\n            setLoading(false);\n            return;\n          }\n        }\n        \n        // Load from network\n        const success = await Image.prefetch(optimizedUrl);\n        if (success) {\n          setImageUri(optimizedUrl);\n          \n          // Cache the result if enabled\n          if (options.cache !== false) {\n            // Estimate size (rough approximation)\n            const estimatedSize = 50 * 1024; // 50KB average\n            await imageCache.set(optimizedUrl, optimizedUrl, estimatedSize);\n          }\n        } else {\n          throw new Error('Failed to load image');\n        }\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Unknown error';\n        setError(errorMessage);\n        \n        // Use fallback if provided\n        if (options.fallback) {\n          setImageUri(options.fallback);\n        }\n        \n        logError(err as Error, {\n          component: 'useOptimizedImage',\n          action: 'loadImage',\n          additionalData: { url: optimizedUrl },\n        });\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    loadImage();\n  }, [optimizedUrl, options.cache, options.fallback]);\n  \n  return {\n    imageUri: imageUri || options.placeholder,\n    loading,\n    error,\n    optimizedUrl,\n  };\n};\n\n/**\n * Hook for batch image preloading\n */\nexport const useImagePreloader = () => {\n  const [preloadProgress, setPreloadProgress] = React.useState(0);\n  const [isPreloading, setIsPreloading] = React.useState(false);\n  \n  const preloadImages = React.useCallback(async (urls: string[]) => {\n    if (urls.length === 0) return;\n    \n    setIsPreloading(true);\n    setPreloadProgress(0);\n    \n    let loaded = 0;\n    const updateProgress = () => {\n      loaded++;\n      setPreloadProgress((loaded / urls.length) * 100);\n    };\n    \n    const promises = urls.map(async (url) => {\n      try {\n        await Image.prefetch(url);\n        updateProgress();\n      } catch (error) {\n        updateProgress(); // Still count as processed\n      }\n    });\n    \n    await Promise.all(promises);\n    setIsPreloading(false);\n    \n    logDebug(`Preloaded ${urls.length} images`);\n  }, []);\n  \n  return {\n    preloadImages,\n    preloadProgress,\n    isPreloading,\n  };\n};\n\n/**\n * Performance-focused lazy image component\n */\nexport const LazyImage: React.FC<{\n  source: { uri: string } | number;\n  style?: any;\n  placeholder?: string;\n  onLoad?: () => void;\n  onError?: (error: any) => void;\n  options?: ImageOptimizationOptions;\n}> = React.memo(({ source, style, placeholder, onLoad, onError, options = {} }) => {\n  const [isInViewport, setIsInViewport] = React.useState(false);\n  const [shouldLoad, setShouldLoad] = React.useState(false);\n  \n  // Lazy loading logic would go here\n  // For now, we'll load immediately\n  React.useEffect(() => {\n    setShouldLoad(true);\n  }, []);\n  \n  const imageSource = typeof source === 'object' && source.uri\n    ? { uri: ImageOptimizer.optimizeUrl(source.uri, options) }\n    : source;\n  \n  if (!shouldLoad && placeholder) {\n    return (\n      <Image\n        source={{ uri: placeholder }}\n        style={style}\n        resizeMode=\"cover\"\n      />\n    );\n  }\n  \n  return (\n    <Image\n      source={imageSource}\n      style={style}\n      onLoad={onLoad}\n      onError={onError}\n      resizeMode=\"cover\"\n    />\n  );\n});\n\n// Export utilities\nexport {\n  imageCache,\n  ImageOptimizer,\n};\n\nexport default {\n  imageCache,\n  ImageOptimizer,\n  useOptimizedImage,\n  useImagePreloader,\n  LazyImage,\n};