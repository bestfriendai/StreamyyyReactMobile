/**
 * Enhanced error reporting and monitoring system
 */
import { config } from '@/config';\nimport { ApiError } from '@/types/api';\n\n/**\n * Error severity levels\n */\nexport enum ErrorSeverity {\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n  CRITICAL = 'critical'\n}\n\n/**\n * Error categories for better organization\n */\nexport enum ErrorCategory {\n  NETWORK = 'network',\n  API = 'api',\n  UI = 'ui',\n  STREAM = 'stream',\n  AUTH = 'auth',\n  STORAGE = 'storage',\n  PERFORMANCE = 'performance',\n  SECURITY = 'security',\n  UNKNOWN = 'unknown'\n}\n\n/**\n * Error context interface\n */\nexport interface ErrorContext {\n  component?: string;\n  action?: string;\n  userId?: string;\n  sessionId?: string;\n  timestamp?: string;\n  additionalData?: Record<string, any>;\n  stackTrace?: string;\n  userAgent?: string;\n  platform?: string;\n  version?: string;\n}\n\n/**\n * Enhanced error interface\n */\nexport interface EnhancedError extends Error {\n  code?: string;\n  severity: ErrorSeverity;\n  category: ErrorCategory;\n  context: ErrorContext;\n  retryable: boolean;\n  originalError?: Error;\n  handled: boolean;\n}\n\n/**\n * Error reporting service\n */\nexport class ErrorReportingService {\n  private static instance: ErrorReportingService;\n  private errorQueue: EnhancedError[] = [];\n  private isOnline = true;\n  private reportingEnabled = true;\n\n  private constructor() {\n    this.setupGlobalErrorHandlers();\n    this.setupNetworkMonitoring();\n  }\n\n  static getInstance(): ErrorReportingService {\n    if (!ErrorReportingService.instance) {\n      ErrorReportingService.instance = new ErrorReportingService();\n    }\n    return ErrorReportingService.instance;\n  }\n\n  /**\n   * Setup global error handlers\n   */\n  private setupGlobalErrorHandlers(): void {\n    // React Native global error handler\n    if (typeof global !== 'undefined' && global.ErrorUtils) {\n      const originalHandler = global.ErrorUtils.getGlobalHandler();\n      \n      global.ErrorUtils.setGlobalHandler((error: Error, isFatal: boolean) => {\n        this.reportError(error, {\n          severity: isFatal ? ErrorSeverity.CRITICAL : ErrorSeverity.HIGH,\n          category: ErrorCategory.UNKNOWN,\n          context: {\n            component: 'GlobalErrorHandler',\n            action: 'unhandledError',\n            additionalData: { isFatal }\n          }\n        });\n        \n        // Call original handler\n        if (originalHandler) {\n          originalHandler(error, isFatal);\n        }\n      });\n    }\n\n    // Promise rejection handler\n    if (typeof window !== 'undefined') {\n      window.addEventListener('unhandledrejection', (event) => {\n        this.reportError(new Error(event.reason), {\n          severity: ErrorSeverity.HIGH,\n          category: ErrorCategory.UNKNOWN,\n          context: {\n            component: 'UnhandledPromiseRejection',\n            action: 'promiseRejection'\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * Setup network monitoring\n   */\n  private setupNetworkMonitoring(): void {\n    if (typeof window !== 'undefined') {\n      window.addEventListener('online', () => {\n        this.isOnline = true;\n        this.flushErrorQueue();\n      });\n      \n      window.addEventListener('offline', () => {\n        this.isOnline = false;\n      });\n    }\n  }\n\n  /**\n   * Report an error with enhanced context\n   */\n  reportError(error: Error, options: Partial<EnhancedError> = {}): void {\n    if (!this.reportingEnabled) return;\n\n    const enhancedError: EnhancedError = {\n      ...error,\n      code: options.code || 'UNKNOWN_ERROR',\n      severity: options.severity || ErrorSeverity.MEDIUM,\n      category: options.category || ErrorCategory.UNKNOWN,\n      context: {\n        timestamp: new Date().toISOString(),\n        userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'Unknown',\n        platform: typeof navigator !== 'undefined' ? navigator.platform : 'Unknown',\n        version: config.environment,\n        ...options.context\n      },\n      retryable: options.retryable || false,\n      originalError: error,\n      handled: false\n    };\n\n    // Log to console in development\n    if (config.logging.enableConsoleLogging) {\n      this.logToConsole(enhancedError);\n    }\n\n    // Add to queue for remote reporting\n    this.errorQueue.push(enhancedError);\n    \n    // Try to send immediately if online\n    if (this.isOnline && config.logging.enableRemoteLogging) {\n      this.flushErrorQueue();\n    }\n\n    // Mark as handled\n    enhancedError.handled = true;\n  }\n\n  /**\n   * Report API errors with specific context\n   */\n  reportApiError(error: ApiError, context: ErrorContext = {}): void {\n    this.reportError(new Error(error.message), {\n      code: error.code,\n      severity: this.getApiErrorSeverity(error.statusCode),\n      category: ErrorCategory.API,\n      context: {\n        ...context,\n        component: 'ApiService',\n        additionalData: {\n          statusCode: error.statusCode,\n          details: error.details\n        }\n      },\n      retryable: this.isApiErrorRetryable(error.statusCode)\n    });\n  }\n\n  /**\n   * Report network errors\n   */\n  reportNetworkError(error: Error, context: ErrorContext = {}): void {\n    this.reportError(error, {\n      severity: ErrorSeverity.HIGH,\n      category: ErrorCategory.NETWORK,\n      context: {\n        ...context,\n        component: 'NetworkService'\n      },\n      retryable: true\n    });\n  }\n\n  /**\n   * Report stream-related errors\n   */\n  reportStreamError(error: Error, streamId: string, context: ErrorContext = {}): void {\n    this.reportError(error, {\n      severity: ErrorSeverity.MEDIUM,\n      category: ErrorCategory.STREAM,\n      context: {\n        ...context,\n        component: 'StreamService',\n        additionalData: {\n          streamId\n        }\n      },\n      retryable: true\n    });\n  }\n\n  /**\n   * Report performance issues\n   */\n  reportPerformanceIssue(metric: string, value: number, threshold: number, context: ErrorContext = {}): void {\n    this.reportError(new Error(`Performance threshold exceeded: ${metric}`), {\n      severity: ErrorSeverity.MEDIUM,\n      category: ErrorCategory.PERFORMANCE,\n      context: {\n        ...context,\n        component: 'PerformanceMonitor',\n        additionalData: {\n          metric,\n          value,\n          threshold\n        }\n      },\n      retryable: false\n    });\n  }\n\n  /**\n   * Log error to console with formatting\n   */\n  private logToConsole(error: EnhancedError): void {\n    const { severity, category, context, message } = error;\n    \n    console.group(`ðŸš¨ ${severity.toUpperCase()} ERROR - ${category.toUpperCase()}`);\n    console.error('Message:', message);\n    console.error('Code:', error.code);\n    console.error('Stack:', error.stack);\n    console.log('Context:', context);\n    console.log('Timestamp:', context.timestamp);\n    console.log('Retryable:', error.retryable);\n    console.groupEnd();\n  }\n\n  /**\n   * Flush error queue to remote service\n   */\n  private async flushErrorQueue(): Promise<void> {\n    if (this.errorQueue.length === 0 || !this.isOnline) return;\n\n    const errorsToSend = [...this.errorQueue];\n    this.errorQueue = [];\n\n    try {\n      // Send to remote logging service\n      await this.sendErrorsToRemote(errorsToSend);\n    } catch (error) {\n      // If sending fails, put errors back in queue\n      this.errorQueue.unshift(...errorsToSend);\n      console.warn('Failed to send errors to remote service:', error);\n    }\n  }\n\n  /**\n   * Send errors to remote logging service\n   */\n  private async sendErrorsToRemote(errors: EnhancedError[]): Promise<void> {\n    // Implementation would depend on your logging service\n    // Example: Sentry, LogRocket, Crashlytics, etc.\n    const payload = {\n      errors: errors.map(error => ({\n        message: error.message,\n        code: error.code,\n        severity: error.severity,\n        category: error.category,\n        context: error.context,\n        stack: error.stack,\n        retryable: error.retryable\n      })),\n      timestamp: new Date().toISOString(),\n      environment: config.environment\n    };\n\n    // Mock API call - replace with actual logging service\n    if (config.logging.enableRemoteLogging) {\n      console.log('Sending errors to remote service:', payload);\n    }\n  }\n\n  /**\n   * Get severity for API errors based on status code\n   */\n  private getApiErrorSeverity(statusCode?: number): ErrorSeverity {\n    if (!statusCode) return ErrorSeverity.MEDIUM;\n    \n    if (statusCode >= 500) return ErrorSeverity.HIGH;\n    if (statusCode >= 400) return ErrorSeverity.MEDIUM;\n    return ErrorSeverity.LOW;\n  }\n\n  /**\n   * Check if API error is retryable\n   */\n  private isApiErrorRetryable(statusCode?: number): boolean {\n    if (!statusCode) return false;\n    \n    // Retry on server errors and rate limits\n    return statusCode >= 500 || statusCode === 429;\n  }\n\n  /**\n   * Enable/disable error reporting\n   */\n  setReportingEnabled(enabled: boolean): void {\n    this.reportingEnabled = enabled;\n  }\n\n  /**\n   * Get error statistics\n   */\n  getErrorStats(): {\n    queueSize: number;\n    isOnline: boolean;\n    reportingEnabled: boolean;\n  } {\n    return {\n      queueSize: this.errorQueue.length,\n      isOnline: this.isOnline,\n      reportingEnabled: this.reportingEnabled\n    };\n  }\n\n  /**\n   * Clear error queue\n   */\n  clearErrorQueue(): void {\n    this.errorQueue = [];\n  }\n}\n\n// Export singleton instance\nexport const errorReporter = ErrorReportingService.getInstance();\n\n// Export convenience functions\nexport const reportError = (error: Error, options?: Partial<EnhancedError>) => \n  errorReporter.reportError(error, options);\n\nexport const reportApiError = (error: ApiError, context?: ErrorContext) => \n  errorReporter.reportApiError(error, context);\n\nexport const reportNetworkError = (error: Error, context?: ErrorContext) => \n  errorReporter.reportNetworkError(error, context);\n\nexport const reportStreamError = (error: Error, streamId: string, context?: ErrorContext) => \n  errorReporter.reportStreamError(error, streamId, context);\n\nexport const reportPerformanceIssue = (metric: string, value: number, threshold: number, context?: ErrorContext) => \n  errorReporter.reportPerformanceIssue(metric, value, threshold, context);\n\n// Export error creation helpers\nexport const createError = (message: string, code: string, category: ErrorCategory, severity: ErrorSeverity = ErrorSeverity.MEDIUM): EnhancedError => {\n  const error = new Error(message) as EnhancedError;\n  error.code = code;\n  error.category = category;\n  error.severity = severity;\n  error.context = {\n    timestamp: new Date().toISOString()\n  };\n  error.retryable = false;\n  error.handled = false;\n  return error;\n};\n\nexport const createApiError = (message: string, statusCode: number, details?: any): ApiError => {\n  return {\n    code: `API_ERROR_${statusCode}`,\n    message,\n    statusCode,\n    details,\n    timestamp: new Date().toISOString()\n  };\n};